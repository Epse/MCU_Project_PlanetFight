% Emacs, this is -*-latex-*-
\documentclass[a4paper, 12pt]{article}
\usepackage[a4paper]{geometry}
\geometry{a4paper,margin=3cm,marginparwidth=20mm}
\usepackage[dutch]{babel}
\usepackage{parskip}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{cancel}
\usepackage{commath}
\usepackage{amssymb}
\usepackage{parskip}
\usepackage{rotating}
\usepackage{listings}
\usepackage{siunitx}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{underscore}
\usepackage{xcolor}
\usepackage{fontspec}
\usepackage{titlesec}
\usepackage{soul}
\usepackage{tikz}
\usepackage[dutch]{todonotes}
\usepackage[pages=some]{background}
% Gives me \intertext and \shortintertext
\usepackage{mathtools}
\usepackage[european, siunitx]{circuitikz}
\usetikzlibrary{calc}
% Nicer unit fractions
\sisetup{per-mode=fraction}
% Smaller margins
% \usepackage{fullpage}
% Clickable links
\usepackage{hyperref}

\newcommand{\TODO}[1]{\textcolor{red}{\large\textbf{TODO}}\todo{#1}}

\lstMakeShortInline[basicstyle=\ttfamily,language=C]{§}

\definecolor{ublauw}{HTML}{1E64C8}
\newfontfamily\panno{Panno Text}
\newfontfamily\ptitle[SizeFeatures={Size=30}]{Panno Text Medium}
\newfontfamily\psec[Scale=1.3, Color=ublauw]{Panno Text Medium}
\titleformat*{\section}{\Large\psec}
\titleformat*{\subsection}{\large\psec}
\titleformat*{\subsubsection}{\itshape\psec}

\begin{document}

\begin{titlepage}
  \setul{}{2pt} % Dikkere onderlijning
  \setuldepth{j} % Beetje ruimte, maar niet zo bizar veel
  \includegraphics[height=1cm]{img/iwa.png}
  \vspace{2cm} \vfill

  \textcolor{ublauw}{\ptitle \uppercase{\ul{Verslag project microcontrollers}}}\\[1em]
  \Large{\panno Marieke Louage, Stef Pletinck, Scoutt Verhelle}
  \vfill

  \includegraphics[height=3cm]{img/logo.png}

\end{titlepage}

\tableofcontents
\listoftodos
\newpage

\section{Doelstellingen}
Doel van deze opgave was het maken van een spel op een microcontroller,
specifiek een \emph{Dwenguino}.
Verdere doelen van het vak zijn het leren lezen en interpreteren van datasheets
en werken met de taal \emph{C}.
Er werd besloten om een multiplayer spel te maken,
voor meer interactiviteit.

Voor de weergave van het spel werden verschillende mogelijkheden overlopen.
Een eerste mogelijkheid was het aansturen van een VGA-display,
maar door de hoge klokfrequentie van VGA en de daaraan gelinkte problemen
werd dit idee snel verworpen.\\
Een tweede idee was het gebruik van een LED-matrix.
De lage resolutie hiervan was echter een groot nadeel,
dus werd uiteindelijk gekozen voor een scherm dat gebruik maakt
van het principe van een hardeschijfklok.

Het spel zelf vindt plaats in een baan rond de aarde, waar twee ruimteschepen
elkaar rond de aarde achtervolgen en proberen neer te schieten.

Als invoer van de spelers werd gekozen voor arcade-joysticks.
Deze bestaan uit vier microswitches per joystick.
Er waren verder nog vele ideeën om het spel verder uit te breiden.

\section{Praktische aanpak}
De nodige functionaliteit werd opgedeeld in logische blokken die met elkaar
communiceren en op elkaar vertrouwen voor informatie. De bekomen structuur is
zichtbaar in figuur~\ref{fig:structuur}.

\begin{figure}
  \centering
  \includegraphics[width=0.8\textwidth]{img/structuur.jpg}
  \caption{Structuur van het microcontrollerprogramma}
  \label{fig:structuur}
\end{figure}


\subsection{Werking display}
Een schijf met gaten draait snel rond over LED's, verspreid in sectoren, zie figuur~\ref{fig:schijf}
Door de LED's op de gepaste momenten in en uit te schakelen
kan een zeer hoge resolutie bekomen worden rond het middelpunt.
In de radiale richting is de resolutie beperkt door het aantal LED's,
dit werd gekozen op 16 om de aansturing werkbaar te houden.

Met deze aanpak is het mogelijk om willekeurig de resolutie te kiezen
waarmee de hoek wordt beschreven. Hoe groter deze resolutie,
hoe meer pixels. Deze waarde werd gekozen op 1024.

\begin{figure}
  \centering
  \includegraphics[width=0.6\textwidth]{img/schijf.png}
  \caption{Schema van de draaischijf}
  \label{fig:schijf}
\end{figure}

\subsection{Aansturing LED's}
De gebruikte LED's zijn ledstrips van het type \texttt{APA102}.
Deze kunnen vrij eenvoudig via SPI data ontvangen.
Elke LED krijgt een pakket bestaande uit 32 bits, zie
figuur~\ref{fig:ledpakket}.
Deze data moet byte per byte en bit per bit verzonden worden over één datalijn,
met een kloksignaal.

De ledstrip luistert naar nieuwe commando's na een startpakket
bestaande uit 32 0-bits. Vervolgens moet,
zoals zichtbaar op figuur~\ref{fig:ledcontrol},
een pakket per LED verstuurd worden gevolgd door
nogmaals 32 bits om te zorgen dat alle data ver genoeg doorgeschoven is.
De waarde van deze bits is onbelangrijk,
maar 0 is handig om te voorkomen dat er een LED op volle helderheid wit licht geeft.

\begin{figure}
  \centering
  \includegraphics[width=0.6\textwidth]{img/ledpakket.png}
  \caption{Schema van een led-pakket}
  \label{fig:ledpakket}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=0.8\textwidth]{img/ledcontrol.png}
  \caption{Schema van het aansturen van een ledstrip}
  \label{fig:ledcontrol}
\end{figure}

Er zijn twee mogelijke manieren om meerdere bytes te versturen over SPI,
via een blokkerende §while§-lus en via een interrupt.
De eerste aanpak wordt getoond in codevoorbeeld~\ref{lst:spiblocking}.

Het is echter ook mogelijk om een interrupt te ontvangen wanneer een byte is
verzonden,
om vervolgens een volgende byte te verzenden. Op die manier kan CPU-tijd
uitgespaard worden maar dit blijkt zeer lastig foutloos te implementeren.
Het spel gebruikt bijgevolg voorlopig nog de \textit{blocking} aanpak.

Het is handig om te weten wat de maximale frequentie is waarmee alle LED's
kunnen aangestuurd worden.
Hiervoor is het belangrijk te weten dat de microcontroller
een werkfrequentie heeft van \SI{16}{\mega\hertz}
en er maximaal 1 bit per 2 klokcycli kan verstuurd worden over SPI.
Er zijn 16 LED's, dit geeft een maximale frequentie van \SI{15625}{\hertz}.

\begin{lstlisting}[frame=lines,language=C,float,caption={Blocking SPI in C},label={lst:spiblocking}]
  unsigned char data = {0xAB, 0xCD, 0x12, 0x34};
  for (unsigned char i = 4; i > 0; i--) {
    SPDR = data[i];
    while (!(SPSR & _BV(SPIF)))
    ;
  }
\end{lstlisting}

\subsection{Timing LED's}
\label{sec:ledtiming}
De juiste LED's moeten op correcte momenten aan en uit geschakeld worden
om op de juiste plaats op de cirkel pixels op te laten lichten,
en niet te lang zodat de pixels geen lijnen worden.

Daartoe wordt voor elk weer te geven object elke \emph{tick} gecontroleerd of
weer kan gegeven worden. Op de vergelijking van de hoek zit er een lichte marge,
zodat elk element zeker wordt weergegeven ook al wordt het scherm niet snel
genoeg opnieuw getekend.

Daartoe krijgt de functie zowel de tijd voor één volledige rotatie,
als de tijd sinds de schijf het nulpunt is gepasseerd als argumenten.
Daaruit kan namelijk de hoek waaronder de schijf staat bepaald worden.

\subsection{Fysieke constructie}
\TODO{Fysieke constructie}

\subsection{Aansturing motor}
De schijf draait rond met behulp van een brushless DC-motor uit een harde schijf.
Om deze aan te sturen is een speciale ESC-module\footnote{ESC: Electronic Speed Control} nodig.

Deze modules zijn ontworpen voor gebruik in quadcopters en verwachten bijgevolg
een speciale aansturing.
Het nodige signaal is een vorm van PWM, met een frequentie van 50 of
\SI{60}{\hertz}
en een pulsbreedte tussen 1 en \SI{2}{\milli\second}.
De PWM-modules die ingebouwd zitten in de microcontroller kunnen niet opereren
in deze frequenties en pulsbreedtelimieten,
het protocol werd dus volledig in software geïmplementeerd.
Zie figuur~\ref{fig:motorpwm} voor een beeld het geproduceerde signaal.

\begin{figure}
  \centering
  \includegraphics[width=0.6\textwidth]{img/scoopcontrolesc.png}
  \caption{Controlesignaal ESC}
  \label{fig:motorpwm}
\end{figure}


Een extra moeilijkheid is de opstartprocedure van de ESC.
De microcontroller moet opgestart zijn en een signaal sturen dat overeen komt
met \SI{0}{\percent} motorvermogen wanneer de ESC stroom krijgt en wordt
ingeschakeld. De ESC produceert dan een serie tonen, gevolgd door een langere
toon wanneer het signaal herkend wordt. Daarna kan de motor aangestuurd worden
en het vermogen verhoogd, liefst langzaam gezien het hoge gewicht van de draaischijf.
Uiteindelijk zal de ESC een driefasig signaal naar de motor sturen, zoals
zichtbaar in figuur~\ref{fig:motoresc}.

\begin{figure}
  \centering
  \includegraphics[width=0.6\textwidth]{img/scoopesc.png}
  \caption{Vermogenssignaal naar de motor}
  \label{fig:motoresc}
\end{figure}


Deze procedure maakt het moeilijk om microcontroller en ESC op één voeding te
laten werken. Door de grote stroom is het ook lastig om bijvoorbeeld de ESC te
schakelen met een transistor. Voorlopig moet de ESC manueel in de stekker
gestoken worden.

\subsection{Toerenteller schijf}
Op de schijf zit een optische sensor, die registreert wanneer een gaatje
passeert. De microcontroller telt nauwkeurig op welk moment dit gebeurt,
zodat afgeleid kan worden hoe snel de schijf draait.
\TODO{Info toerenteller}

\subsection{Joysticks}
De beide joysticks zijn relatief eenvoudig om uit te lezen.
Ze bestaan telkens uit vier NO schakelaars, één per richting.
Aangezien elke joystick op een aparte \emph{port} van de microcontroller
aangesloten is, kan met een simpele NOT operatie en enkele bitshifts een
consistente weergave gegenereerd worden, met 1 bit per richting die hoog is
wanneer de schakelaar actief is. Hiertoe moeten ook de pullups geactiveerd
worden. De driver voor de joysticks controleert ook welke schakelaars sinds de
laatste tick actief zijn geworden, en slaat deze apart op.

Enkele gemaksfuncties werden toegevoegd om uit deze bitweergave te bepalen of
een gekozen richting actief is.

\subsection{Game engine}
De game engine werkt op een relatief eenvoudig principe,
op regelmatige basis wordt de functie §uint8_t tick(uint16_t time_since_zero)§
opgeroepen,
deze voert enkele stappen uit:
\begin{enumerate}
  \item \emph{Tick alle entities\footnote{Entities zijn bijvoorbeeld kogels en
        spelers}}, entities hebben een §tick()§ functie,\\
    bijvoorbeeld §player_tick(Player *p)§, die ervoor zorgt dat de entity zich
    verplaatst volgens zijn snelheid en eventueel reageert op invoer.

  \item \emph{Controleer voor botsingen}, in deze stap wordt getest of er
    kogels een schip geraakt hebben, en eventueel levens van deze speler worden
    afgenomen.

  \item \emph{Render} is het bepalen van welke entities zichtbaar zijn en het
    omzetten van deze entities naar LED-informatie. Deze gegevens worden dan
    doorgestuurd naar de LED-timer (zie sectie~\ref{sec:ledtiming}) voor weergave.

  \item \emph{Check voor het einde van het spel} door te controleren of beide
    spelers nog in leven zijn. Dit bepaalt de returnwaarde van deze functie,
    §true§ wanneer het spel moet verder gaan, anders §false§.
\end{enumerate}

Deze functie moet in theorie de tijd sinds ze laatst is opgeroepen in overweging
nemen, om te vermijden dat de schijnbare snelheid van objecten varieert,
of de functie moet heel regelmatig opgeroepen worden.

\section{Problemen}
\subsection{ESC}
Na een eerste poging bleek dat de ESC de motor niet kon laten draaien.
De motor gaf wat schokjes en de ESC produceerde niet de gewenste opstarttonen.
Na de massakabel van de motor los te maken bleek alles correct te functioneren.
Het is onbekend waarom dit een probleem gaf.

\section{Taakverdeling}
\TODO{\hspace{0pt}Taakverdeling}

\end{document}
